#!/usr/bin/php
<?php

# changelog appender
# appends lines to changelogs within files
# by robert klebe, dotpointer

# changelog
# 2018-07-15 18:56:00 - first version

# get argument options
$opts = getopt(
  'bc:d:hi:l:m:o:qwv:',
  array(
    'config:',
    'config-write:',
    'date:',
    'help:',
    'input:',
    'line:',
    'linelimit:',
    'minimumdiff:',
    'output:',
    'quiet',
    'write',
    'verbose:',
    'loglevel:',
    'logfile:'
  )
);

# verbosity levels
define('VERBOSE_OFF', 0);		# no info at all
define('VERBOSE_ERROR', 1);		# only errors
define('VERBOSE_INFO', 2);		# above and things that changes
define('VERBOSE_DEBUG', 3);		# above and verbose info
define('VERBOSE_DEBUG_DEEP', 4);		# above and exec outputs

# default config
$config = array(
  'config' => '/etc/dptools/'.basename(__FILE__),
  'backup' => true,
  'date' => time(),
  'input' => false,
  'line' => false,
  'linelimit' => 200,
  'logfile' => '/var/log/'.basename(__FILE__),
  'loglevel' => VERBOSE_OFF,
  'minimumdiff' => 60 * 15,
  'output' => false,
  'verbose' => VERBOSE_ERROR,
  'write' => false
);

# override default config if it has been set
if (isset($opts['config'])) {
  $config['config'] = $opts['config'];
}

# try to read global config
if (file_exists($config['config'])) {
  if (!$tmp = file_get_contents($config['config'])) {
    cl('Failed reading config file '.$config['config'].'.');
    die(1);
  }
  if (!$tmp = json_decode($config['config'])) {
    cl('Failed JSON decoding config file '.$config['config'].'.');
    die(1);
  }
  $config = array_merge($config, $tmp);
}

# debug printing
function cl($s, $level=1) {
    global $config;

	# find out level of verbosity
	switch ($level) {
		case VERBOSE_ERROR:
			$l = 'E';
			break;
		case VERBOSE_INFO:
			$l = 'I';
			break;
		case VERBOSE_DEBUG:
		case VERBOSE_DEBUG_DEEP:
			$l = 'D';
			break;
	}
	$s = ''.date('Y-m-d H:i:s').' '.$l.' '.$s."\n";

	# is verbosity on and level is enough?
	if ($config['verbose'] && $config['verbose'] >= $level) {
		echo $s;
	}

	# is loglevel on and level is enough - the try to append to log
	if ($config['loglevel'] && $config['loglevel'] >= $level && $f = fopen($config['logfile'], 'a')) {
		fwrite($f, $s);
		fclose($f);
	}

	return true;
}

# walk argument options
foreach ($opts as $opt => $value) {
  switch ($opt) {
    case 'b':
    case 'no-backup':
      $config['backup'] = false;
      break;
    case 'c': # quantity of lines to check
    case 'linelimit':
      $config['linelimit'] = (int)$value;
      break;
    case 'config':
      $config['config'] = strtotime($value);
      break;
    case 'config-write':
      # make json and indentation by 2
      $json_indented_by_4 = json_encode($config, JSON_UNESCAPED_SLASHES|JSON_PRETTY_PRINT);
      $json_indented_by_2 = preg_replace('/^(  +?)\\1(?=[^ ])/m', '$1', $json_indented_by_4);
      file_put_contents($config['config'], $json_indented_by_2);
      cl('Writing config to '.$config['config'].'.'."\n", VERBOSE_INFO);
      die();
    case 'date':
      $config['date'] = strtotime($value);
      break;
    case 'h': # print help
    case 'help':
?>
Changelog appender

Usage: <?php echo basename(__FILE__)?> <options>

Options:
  -b, --no-backup
    Turn off backup.
    Defaults to make backup named input.backup-date
  -c <number>, --linelimit=<number>
    Sets the amount of lines to check.
    Defaults to 200.
  -d <date [time]>, --date="date [time]"
    Date and time to set on line.
    Defaults to current date and time.
  -i <file>, --input=<file>
    The file to edit.
  -h, --help
    Print this information.
  -l <line>, --line=<line>
    The line to add to the changelog in the file.
    Defaults to empty.
  --logfile=<file>
    Sets logfile.
    Defaults to /var/log/<?php echo basename(__FILE__) ?>.
  --loglevel=<0-4>
    Sets loglevel.
    0 = off, 1 = errors, 2 = info, 3-4 debug.
    Defaults to 0.
  -m <seconds>, --minimumdiff=<seconds>
    Minimum time in seconds between last changelog date and
    file modification date before it appends the file modification date
    to the changelog before the line to insert.
    Defaults to 15 minutes.
  -o <file>, --output=<file>
    File to output changes to.
  -w, --write
    Actually write the changes.
    Defaults to not writing changes.
  -v <0-4>, --verbose=<0-4>
    Sets verbosity level.
    0 = off, 1 = errors, 2 = info, 3-4 debug.
    Defaults to 1.
<?php
      die();
    case 'i': # file to work on
    case 'input':
      $config['input'] = $value;
      break;
    case 'l': # line to append to changelog
    case 'line':
      $config['line'] = $value;
      break;
    case 'logfile':
      $config['logfile'] = $v;
      break;
    case 'loglevel':
      $config['loglevel'] = (int)$v;
      break;
    case 'm': # minimum seconds in diff before appding file modification date
    case 'minimumdiff':
      $config['minimumdiff'] = $value;
      break;
    case 'o': # file to work on
    case 'output':
      $config['output'] = $value;
      break;
    case 'w':
    case 'write':
      $config['write'] = true;
      break;
    case 'v':
    case 'verbose':
      $config['verbose'] = (int)$value;
      break;
  }
}

function linenrprefix($linenr, $linecount) {
  return str_pad($linenr, strlen((string)$linecount), '0', STR_PAD_LEFT);
}

# make sure input file is set
if (!$config['input']) {
  cl('No input file specified.', VERBOSE_ERROR);
  die(1);
}

# make sure output file is set
if (!$config['output']) {
  cl('No output file specified.', VERBOSE_ERROR);
  die(1);
}

# make sure file exists
if (!file_exists($config['input'])) {
  cl('Input file '.$config['input'].' does not exist.');
  die(1);
}

# open the file
if (!$f = fopen($config['input'], 'r')) {
  cl('Error: failed opening '.$config['input'].'.');
  die(1);
}

# get the first x lines
# do it without head + grep to avoid potential uncacheable
# errors from head and reuse the read
$lines = array();
$linenr = 0;
while (($line = fgets($f)) !== false) {
  $lines[] = $line;
  $linenr++;
}

$linecount = $linenr;

if (!feof($f)) {
  cl('Failed reading '.$config['input']);
  die(1);
}

# close file
fclose($f);

# make sure there are lines
if (!count($lines)) {
  cl('No lines', VERBOSE_DEBUG);
  die();
}

$append = array();
$appendcharacter = false; # false = new line, number, substring into line
$appendlinenr = false;
$appendmodtime = true;
$changelog = false;
$continue = true;
$filetype = false;
$lastdate = false;
$lastlinedateline = false;
$mime = mime_content_type($config['input']);
$mode = 0;
$modtime = filemtime($config['input']);
$prefix = '';
$shebang = false;

$extension = basename($config['input']);
$extension = strpos($extension, '.') !== false ? strtolower(substr($extension, strrpos($extension, '.') + 1)) : false;

cl('Input file: '.$config['input'], VERBOSE_INFO);
cl('Output file: '.$config['output'], VERBOSE_INFO);
cl('Backup file: '.($config['backup'] ? 'yes' : 'no'), VERBOSE_DEBUG);
cl('Write changes: '.($config['write'] ? 'yes' : 'no'), VERBOSE_DEBUG);
cl('Extension: '.$extension, VERBOSE_DEBUG);
cl('MIME: '.$mime, VERBOSE_DEBUG);
cl('Modified: '.date('Y-m-d H:i:s', $modtime), VERBOSE_DEBUG);
cl('Line limit: '.$config['linelimit'], VERBOSE_DEBUG);

# walk lines to find append point - changelog
foreach ($lines as $linenr => $line) {

  # check line limit
  if ($linenr + 1 >= $config['linelimit']) {
    cl('Reached '.$config['linelimit'].' lines limit, stopping.', VERBOSE_DEBUG);
    break;
  }

  # clean the line from spaces, tabs and new lines
  $line = trim($line);

  # first line and this is a shebang?
  if ($linenr === 0 && substr($line, 0, 2) === '#!') {
    cl('Line '.linenrprefix($linenr, $linecount).': shebang, '.$line, VERBOSE_DEBUG_DEEP);
    $shebang = $linenr;
  }

  # check mime
  switch ($mime) {
    case 'text/x-php':
    case 'text/x-shellscript':
      # mode 0 = looking for changelog
      # mode 1 = looking for dateline

      # find out current mode
      switch ($mode) {
        case 0: # looking for changelog
          # find "# changelog"
          unset($matches);
          if (preg_match("/^\s*(\#*\s*)?changelog\s*$/i", $line, $matches)) {
            $mode = 1;
            $changelog = $linenr;
            cl('Line '.linenrprefix($linenr, $linecount).': "changelog" found: '.$line, VERBOSE_DEBUG_DEEP);

            # is there a prefix
            if (isset($matches[1])) {
              $prefix = $matches[1];
            }
          }
          break;
        case 1: # find date line
          # empty line - can be something
          if (!strlen($line)) {
            $lastlinedateline = false;
            $appendlinenr = $linenr;
            break;
          }

          # just an empty commented line?
          if (preg_match("/^\#+$/", $line)) {
            $lastlinedateline = false;
            $appendlinenr = $linenr;
            break;
          }

          # find "# xxxx-xx-xx xx:xx:xx - possibly something"
          unset($matches);
          $regex = "/^\s*(\#*\s*)?([\d|x]{4,}\-[\d|x]{2}\-[\d|x]{2})(\s+[\d|x]{2,}\:[\d|x]{2}(\:[\d|x]{2})?)?.*.*$/i";
          if (preg_match($regex, $line, $matches)) {

            # is there a prefix?
            if (strpos($matches[1], '#') !== false) {
              $prefix = $matches[1];
              $lastdate = $matches[2].(isset($matches[3]) ? $matches[3] : '');
            } else {
              $lastdate = $matches[1].(isset($matches[2]) ? $matches[2] : '');
            }

            # any unfilled positions in this date? then it is unusable
            if (strpos($lastdate, 'x')) {
              $lastdate = false;
              cl('Line '.linenrprefix($linenr, $linecount).': dateline, unusable: '.$line, VERBOSE_DEBUG_DEEP);
            } else {
              cl('Line '.linenrprefix($linenr, $linecount).': dateline, usable: '.strtotime('Y-m-d H:i:s', strtotime($lastdate)).': '.$line, VERBOSE_DEBUG_DEEP);
            }

            $lastlinedateline = true;
            break;
          }

          # was last line a date line and there is an indented line?
          # then go next, this can go on for a while
          if ($lastlinedateline && preg_match("/^\s*#*\s*.*$/", $line)) {
              cl('Line '.linenrprefix($linenr, $linecount).': dateline, possible continuation.', VERBOSE_DEBUG_DEEP);
            break;
          }
          $lastlinedateline = false;

          cl('Line '.linenrprefix($linenr, $linecount).': read stop, unknown data found: '.$line, VERBOSE_DEBUG_DEEP);
          # something else, stop here
          $continue = false;
          break;
      }
      break;
  } # mime
  # for-each stopper
  if (!$continue) {
    break;
  }
}

# still no linenr - detect default prefix
if ($appendlinenr === false) {
  switch ($mime) {
    case 'text/x-php':
    case 'text/x-shellscript':
      $prefix = '#  ';
      break;
  }
}

# has last date been found?
if ($lastdate) {
  $lastdate = strtotime($lastdate);
    cl('Last changelog date: '.date('Y-m-d H:i:s', $lastdate), VERBOSE_DEBUG);
  $diff = $modtime - $lastdate;
  cl('Diff between changelog last date and file modification date: '.$diff.' s.', VERBOSE_DEBUG);
  # is date within interval?
  if ($diff < $config['minimumdiff']) {
    $appendmodtime = false;
  }
}

# should mod time be included in list?
if ($appendmodtime) {
  cl('Appending file modification date to changelog.', VERBOSE_DEBUG);
  $append[] = $prefix.date('Y-m-d H:i:s', $modtime)."\n";
} else {
  cl('Not appending file modification date to changelog.', VERBOSE_DEBUG);
}

# compose the actual line to append
$append[] = $prefix.date('Y-m-d H:i:s', $config['date']).(strlen($config['line']) ? ' - '.$config['line'] : '')."\n";

# still no linenr - find out how to insert anyway
if ($appendlinenr === false) {
  # is there a shebang, then begin after that
  $appendlinenr = $shebang ? 1 : 0;
  $appendcharacter = $shebang !== false ? false : 0;

  switch ($mime) {
    case 'text/x-php':
      $append = array_merge(
        array(
          '<?php',
          $prefix.'changelog'
        ),
        $append,
        array(
          '?>'
        )
      );
      break;
    case 'text/x-shellscript':
      $append = array_merge(
        array(
          $prefix.'changelog'
        ),
        $append
      );
      break;
  }
}

cl('Prefix: "'.$prefix.'".', VERBOSE_DEBUG);
cl('Append line nr: '.($appendlinenr !== false ? $appendlinenr : 'none found').'.', VERBOSE_DEBUG);
cl('Append character: "'.$appendcharacter.'".', VERBOSE_DEBUG);

if ($appendlinenr === false) {
  cl('No suitable append line nr found, exiting.', VERBOSE_INFO);
  exit;
}

# recalculate line count, if append character is on,
# then one existing line will be edited, reducing the
# number of lines edited
$linecount = $linecount + count($append) + ($appendcharacter !== false ? -1 : 0);

# make backup?
if ($config['backup']) {

  # find suitable backup name
  $i = '';
  do {
    $copytarget = $config['input'].'.backup-'.date('Y-m-d_His').$i;
    if (file_exists($copytarget)) {
      $i = is_numeric($i) ? $i + 1 : 1;
    }
  } while(file_exists($copytarget));

  # do backup
  cl('Backing up '.$config['input']. ' to '.$copytarget.'.', VERBOSE_INFO);
  if ($config['write']) {
    if (!copy($config['input'], $copytarget)) {
      cl('Error, failed doing backup of '.$config['input'].' to '.$copytarget.'.', VERBOSE_DEBUG);
      die(1);
    }
  }
}

# open file
cl('Opening file '.$config['output'].' for writing.', VERBOSE_INFO);
if ($config['write']) {
  if (!$f = fopen($config['output'], 'w')) {
      cl('Error, failed opening '.$config['output'], VERBOSE_ERROR);
      die(1);
  }
}

# walk lines
$linenrsadded = 0;
foreach ($lines as $linenr => $line) {

  # line to append in?
  if ($linenr === $appendlinenr) {
    # append in character in line?
    if ($appendcharacter !== false) {

      # beginning and end of the line
      $begin = substr($line, 0, $appendcharacter);
      $end = substr($line, $appendcharacter);

      # walk the lines to append
      foreach ($append as $k => $v) {
        # first index?
        if ($k === 0) {
          # add the line from the start to the character in line
          $append[$k] = $begin.$v;
        }
        # last index?
        if ($k === count($append)-1) {
          # add the ending of the line
          $append[$k] = $v.$end;
        }
      }
    }
    # walk lines to append and do it
    foreach ($append as $k => $appendline) {
      cl('Out '.linenrprefix($linenr + $linenrsadded, $linecount).'+: '.trim($appendline), VERBOSE_DEBUG);
      if ($config['write']) {
        fputs($f, $appendline);
      }
      # above append line 0 or append character is off
      if ($k > 0 || ($k === 0 && $appendcharacter === false)) {
        # increment lines added
        $linenrsadded++;
      }
    }

    # not appending on character?
    if ($appendcharacter === false) {
      # then print original line afterwards
      cl('Out '.linenrprefix($linenr + $linenrsadded, $linecount).'+: '.trim($line), VERBOSE_DEBUG);
      if ($config['write']) {
        fputs($f, $line);
      }
    }
  } else {
    # write regular line
    cl('Out '.linenrprefix($linenr + $linenrsadded, $linecount).' : '.trim($line), VERBOSE_DEBUG_DEEP);
    if ($config['write']) {
      fputs($f, $line);
    }
  }
}

# close file
if ($config['write']) {
  fclose($f);
}

?>
