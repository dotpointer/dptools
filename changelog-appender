#!/usr/bin/php
<?php

# changelog appender
# appends lines to changelogs within files
# by robert klebe, dotpointer

# changelog
# 2018-07-15 18:56:00 - first version

# verbosity levels
define('VERBOSE_OFF', 0);    # no info at all
define('VERBOSE_ERROR', 1);    # only errors
define('VERBOSE_INFO', 2);    # above and things that changes
define('VERBOSE_DEBUG', 3);    # above and verbose info
define('VERBOSE_DEBUG_DEEP', 4);    # above and exec outputs

# default config
$config = array(
  'config' => '/etc/dptools/'.basename(__FILE__),
  'backup' => true,
  'date' => time(),
  'input' => false,
  'line' => false,
  'linelimit' => 200,
  'logfile' => '/var/log/'.basename(__FILE__),
  'loglevel' => VERBOSE_OFF,
  'minimumdiff' => 60 * 15,
  'output' => false,
  'verbose' => VERBOSE_ERROR,
  'write' => false
);

# debug printing
function cl($s, $level=1) {
    global $config;

  # find out level of verbosity
  switch ($level) {
    case VERBOSE_ERROR:
      $l = 'E';
      break;
    case VERBOSE_INFO:
      $l = 'I';
      break;
    case VERBOSE_DEBUG:
    case VERBOSE_DEBUG_DEEP:
      $l = 'D';
      break;
  }
  $s = ''.date('Y-m-d H:i:s').' '.$l.' '.$s."\n";

  # is verbosity on and level is enough?
  if (
      $config['verbose'] &&
      $config['verbose'] >= $level
    ) {
    echo $s;
  }

  # is loglevel on and level is enough - the try to append to log
  if (
      $config['loglevel'] &&
      $config['loglevel'] >= $level &&
      $f = fopen($config['logfile'], 'a')
    ) {
    fwrite($f, $s);
    fclose($f);
  }

  return true;
}

# get argument options
$opts = getopt(
  'b:c:d:hi:l:m:o:wv:',
  array(
    'backup:',
    'config:',
    'config-write',
    'date:',
    'help',
    'input:',
    'line:',
    'linelimit:',
    'minimumdiff:',
    'output:',
    'write',
    'verbose:',
    'loglevel:',
    'logfile:'
  )
);

# override default config if it has been set
if (isset($opts['config'])) {
  $config['config'] = $opts['config'];
}

# try to read global config
if (file_exists($config['config'])) {
  if (!$tmp = file_get_contents($config['config'])) {
    cl('Failed reading config file '.$config['config'].'.', VERBOSE_ERROR);
    die(1);
  }
  # strip config comments
  $tmp = explode("\n", $tmp);
  foreach ($tmp as $k => $v) {
      $tmp[$k] = preg_replace('/^\s*\#+.*$/', '',$v);
  }
  $tmp = implode("\n", $tmp);
  if (!$tmp = json_decode($tmp, true)) {
    cl('Failed JSON decoding config file '.$config['config'].'.', VERBOSE_ERROR);
    die(1);
  }
  $config = array_merge($config, $tmp);
}

# walk argument options
foreach ($opts as $opt => $value) {
  switch ($opt) {
    case 'b':
    case 'backup':
      $config['backup'] = (int)$value === 1;
      break;
    case 'c': # quantity of lines to check
    case 'linelimit':
      $config['linelimit'] = (int)$value;
      break;
    case 'config':
      $config['config'] = strtotime($value);
      break;
    case 'config-write':
      # make json and indentation by 2
      $json_indented_by_4 = json_encode($config, JSON_UNESCAPED_SLASHES|JSON_PRETTY_PRINT);
      $json_indented_by_2 = preg_replace('/^(  +?)\\1(?=[^ ])/m', '$1', $json_indented_by_4);
      file_put_contents($config['config'], $json_indented_by_2);
      cl('Writing config to '.$config['config'].'.', VERBOSE_INFO);
      die();
    case 'date':
      $config['date'] = strtotime($value);
      break;
    case 'h': # print help
    case 'help':
?>
Changelog appender

Usage: <?php echo basename(__FILE__)?> <options>

Options:
  -b <0/1>, --backup
    Turn backup on or off.
    Defaults to make backup named input.backup-date.

  -c <number>, --linelimit=<number>
    Sets the amount of lines to check.
    Defaults to 200.

  -d <date [time]>, --date="date [time]"
    Date and time to set on line.
    Defaults to current date and time.

  -i <file>, --input=<file>
    The file to edit.

  -h, --help
    Print this information.

  -l <line>, --line=<line>
    The line to add to the changelog in the file.
    Defaults to empty.
  --logfile=<file>
    Sets logfile.
    Defaults to /var/log/<?php echo basename(__FILE__) ?>.

  --loglevel=<0-4>
    Sets loglevel.
    0 = off, 1 = errors, 2 = info, 3-4 debug.
    Defaults to 0.

  -m <seconds>, --minimumdiff=<seconds>
    Minimum time in seconds between last changelog date and
    file modification date before it appends the file modification date
    to the changelog before the line to insert.
    Defaults to 15 minutes.

  -o <file>, --output=<file>
    File to output changes to.

  -w, --write
    Actually write the changes.
    Defaults to not writing changes.

  -v <0-4>, --verbose=<0-4>
    Sets verbosity level.
    0 = off, 1 = errors, 2 = info, 3-4 debug.
    Defaults to 1.
<?php
      die();
    case 'i': # file to work on
    case 'input':
      $config['input'] = $value;
      break;
    case 'l': # line to append to changelog
    case 'line':
      $config['line'] = $value;
      break;
    case 'logfile':
      $config['logfile'] = $value;
      break;
    case 'loglevel':
      $config['loglevel'] = (int)$value;
      break;
    case 'm': # minimum seconds in diff before appding file modification date
    case 'minimumdiff':
      $config['minimumdiff'] = $value;
      break;
    case 'o': # file to work on
    case 'output':
      $config['output'] = $value;
      break;
    case 'w':
    case 'write':
      $config['write'] = true;
      break;
    case 'v':
    case 'verbose':
      $config['verbose'] = (int)$value;
      break;
  }
}

# increment zero-starting line number and prefix with zeros
function linenrprefix($linenr, $linecount) {
  return str_pad($linenr + 1, strlen((string)$linecount), '0', STR_PAD_LEFT);
}

# make sure input file is set
if (!$config['input']) {
  cl('No input file specified.', VERBOSE_ERROR);
  die(1);
}

# make sure output file is set
if (!$config['output']) {
  cl('No output file specified.', VERBOSE_ERROR);
  die(1);
}

# make sure input file exists
if (!file_exists($config['input'])) {
  cl('Input file '.$config['input'].' does not exist.');
  die(1);
}

# open the input file
if (!$f = fopen($config['input'], 'r')) {
  cl('Error: failed opening '.$config['input'].'.');
  die(1);
}

# get the first x lines
# do it without head + grep to avoid potential uncacheable
# errors from head and reuse the read
$linenr = 0;
$lines = array();
while (($line = fgets($f)) !== false) {
  $lines[] = $line;
  $linenr++;
}

$linecount = $linenr;

if (!feof($f)) {
  cl('Failed reading '.$config['input']);
  die(1);
}

# close input file
fclose($f);

# make sure there are lines
if (!count($lines)) {
  cl('No lines in input file.', VERBOSE_DEBUG);
  die();
}

$append = array();
$appendcharacter = false; # false = new line, number, substring into line
$appendlinenr = false;
$appendmodtime = true;
$continue = true;
$lastdate = false;
$lastlinedateline = false;
$mime = mime_content_type($config['input']);
$mode = 0;
$modtime = filemtime($config['input']);
$prefix = '';
$shebang = false;

cl('Input file: '.$config['input'].'.', VERBOSE_INFO);
cl('Output file: '.$config['output'].'.', VERBOSE_INFO);
cl('Backup file: '.($config['backup'] ? 'yes' : 'no').'.', VERBOSE_DEBUG);
cl('Write changes: '.($config['write'] ? 'yes' : 'no').'.', VERBOSE_DEBUG);
cl('Extension: "'.$extension.'".', VERBOSE_DEBUG);
cl('MIME: '.$mime, VERBOSE_DEBUG);
cl('Modified: '.date('Y-m-d H:i:s', $modtime).'.', VERBOSE_DEBUG);
cl('Line limit: '.$config['linelimit'].'.', VERBOSE_DEBUG);

# walk lines to find append point - changelog
foreach ($lines as $linenr => $line) {

  # check line limit
  if ($linenr + 1 >= $config['linelimit']) {
    cl('Reached '.$config['linelimit'].' lines limit, stopping.', VERBOSE_DEBUG);
    break;
  }

  # clean the line from spaces, tabs and new lines
  # $line = trim($line);

  # first line and this is a shebang?
  if ($linenr === 0 && substr($line, 0, 2) === '#!') {
    cl('Line '.linenrprefix($linenr, $linecount).': shebang, '.$line, VERBOSE_DEBUG_DEEP);
    $shebang = $linenr;
    continue;
  }

  # check mime
  switch ($mime) {
    case 'text/x-php':
    case 'text/x-shellscript':
      # mode 0 = looking for changelog
      # mode 1 = looking for dateline

      unset($matches);
      # mode 0 + changelog
      if (
        $mode === 0 &&
        preg_match("/^\s*(\#*\s*)?changelog\s*$/i", $line, $matches)
      ) {
        # engage mode 1
        $mode = 1;
        $appendlinenr = $linenr + 1;
        cl(
          'Line '.linenrprefix($linenr, $linecount).
          ': "changelog" found: '.$line,
          VERBOSE_DEBUG_DEEP
        );

        # is there a prefix
        if (isset($matches[1])) {
          $prefix = $matches[1];
        }
        break;
      }

      # mode 1 + empty line - can be something
      if (
        $mode === 1 &&
        (!strlen($line) || preg_match("/^\s*\#+\s*$/", $line))
      ) {
        $lastlinedateline = false;
        $appendlinenr = $linenr + 1;
        break;
      }

      # mode 0-1 + "# xxxx-xx-xx xx:xx:xx - possibly something"
      unset($matches);
      $regex  = "/^\s*(?P<prefix>\#*\s*)?";
      $regex .= "(?P<year>[\d|x]{4,})\-";
      $regex .= "(?P<month>[\d|x]{2})\-";
      $regex .= "(?P<day>[\d|x]{2})";
      $regex .= "(\s+(?P<hour>[\d|x]{2,})\:";
      $regex .= "(?P<minute>[\d|x]{2})";
      $regex .= "(\:(?P<second>[\d|x]{2}))?)?.*.*$/i";
      if (preg_match($regex, $line, $matches)) {

        # we are now in mode 1
        $mode = 1;

        $matches = array_filter($matches, "is_string", ARRAY_FILTER_USE_KEY);
        $prefix = isset($matches['prefix']) ? $matches['prefix'] : $prefix;

        $lastdate = false;
        # year-month-day
        if (
          isset($matches['year']) && is_numeric($matches['year']) &&
          isset($matches['month']) && is_numeric($matches['month']) &&
          isset($matches['day']) && is_numeric($matches['day']) &&
          checkdate($matches['month'], $matches['day'], $matches['year'])
        ) {

          $lastdate = $matches['year'].'-'.$matches['month'].'-'-$matches['day'];

          # hour-minute
          if (
            isset($matches['hour']) && is_numeric($matches['hour']) &&
            isset($matches['minute']) && is_numeric($matches['minute']) &&
            (int)$matches['hour'] >= 0 &&
            (int)$matches['hour'] <= 23 &&
            (int)$matches['minute'] >= 0 &&
            (int)$matches['minute'] <= 59
          ) {
            $lastdate .= $matches['hour'].'-'.$matches['minute'];

            # second
            if (
              isset($matches['second']) && is_numeric($matches['second']) &&
              (int)$matches['second'] >= 0 &&
              (int)$matches['second'] <= 59
            ) {
              $lastdate .= $matches['second'];
            }
          }
        }

        # any unfilled positions in this date? then it is unusable
        if ($lastdate === false) {
          cl('Line '.linenrprefix($linenr, $linecount).': dateline, unusable: '.$line, VERBOSE_DEBUG_DEEP);
        } else {
          cl('Line '.linenrprefix($linenr, $linecount).': dateline, usable: '.strtotime('Y-m-d H:i:s', strtotime($lastdate)).': '.$line, VERBOSE_DEBUG_DEEP);
        }

        # append on next line
        $appendlinenr = $linenr + 1;

        # last line was a date line
        $lastlinedateline = true;
        break;
      }

      # was last line a date line and there is an indented line?
      # then go next, this can go on for a while
      if ($mode === 1 && $lastlinedateline && preg_match("/^\s*#*\s*.*$/", $line)) {
        cl('Line '.linenrprefix($linenr, $linecount).': dateline, possible continuation.', VERBOSE_DEBUG_DEEP);
        break;
      }

      # obviously last line was not a date line
      $lastlinedateline = false;

      # mode 1 and passed dateline checks and so on
      if ($mode === 1) {
        cl('Line '.linenrprefix($linenr, $linecount).': read stop, unknown data found: '.$line, VERBOSE_DEBUG_DEEP);
        # something else, stop here
        $continue = false;
        break;
      }
  } # mime
  # for-each stopper
  if (!$continue) {
    break;
  }
}

# still no linenr - set default prefix
if ($appendlinenr === false) {
  switch ($mime) {
    case 'text/x-php':
    case 'text/x-shellscript':
      $prefix = '#  ';
      break;
  }
}

# has last date been found?
if ($lastdate) {
  $lastdate = strtotime($lastdate);
  cl('Last changelog date: '.date('Y-m-d H:i:s', $lastdate), VERBOSE_DEBUG);
  $diff = $modtime - $lastdate;
  cl('Diff between changelog last date and file modification date: '.$diff.' s.', VERBOSE_DEBUG);
  # is date within interval?
  if ($diff < $config['minimumdiff']) {
    $appendmodtime = false;
  }
}

# should mod time be included in list?
if ($appendmodtime) {
  cl('Appending file modification date to changelog.', VERBOSE_DEBUG);
  $append[] = $prefix.date('Y-m-d H:i:s', $modtime);
} else {
  cl('Not appending file modification date to changelog.', VERBOSE_DEBUG);
}

# compose the actual line to append
$append[] = $prefix.date('Y-m-d H:i:s', $config['date']).(strlen($config['line']) ? ' - '.$config['line'] : '');

# still no linenr - find out how to insert anyway
if ($appendlinenr === false) {

  switch ($mime) {
    case 'text/x-php':
    case 'text/x-shellscript':
      # is there a shebang, then begin after that
      $appendlinenr = $shebang ? 1 : 0;
      $appendcharacter = $shebang !== false ? false : 0;
      break;
  }

  switch ($mime) {
    case 'text/x-php':
      $append = array_merge(
        array(
          '<?php',
          $prefix.'changelog'
        ),
        $append,
        array(
          '?>'
        )
      );
      break;
    case 'text/x-shellscript':
      $append = array_merge(
        array(
          $prefix.'changelog'
        ),
        $append
      );
      break;
  }
}

cl('Prefix: "'.$prefix.'".', VERBOSE_DEBUG);
cl('Append line nr: '.($appendlinenr !== false ? $appendlinenr : 'none found').'.', VERBOSE_DEBUG);
cl('Append character nr: '.$appendcharacter.'.', VERBOSE_DEBUG);

if ($appendlinenr === false) {
  cl('No suitable append line nr found, exiting.', VERBOSE_INFO);
  exit;
}

# recalculate line count, if append character is on,
# then one existing line will be edited, reducing the
# number of lines edited
$linecount = $linecount + count($append) + ($appendcharacter !== false ? -1 : 0);

# make backup?
if ($config['backup']) {

  # find suitable backup name
  $i = '';
  do {
    $copytarget = $config['input'].'.backup-'.date('Y-m-d_His').$i;
    if (file_exists($copytarget)) {
      $i = is_numeric($i) ? $i + 1 : 1;
    }
  } while(file_exists($copytarget));

  # do backup
  cl('Backing up '.$config['input']. ' to '.$copytarget.'.', VERBOSE_INFO);
  if ($config['write']) {
    if (!copy($config['input'], $copytarget)) {
      cl('Error, failed doing backup of '.$config['input'].' to '.$copytarget.'.', VERBOSE_DEBUG);
      die(1);
    }
  }
}

# open file
cl('Opening file '.$config['output'].' for writing.', VERBOSE_INFO);
if ($config['write']) {
  if (!$f = fopen($config['output'], 'w')) {
      cl('Error, failed opening '.$config['output'], VERBOSE_ERROR);
      die(1);
  }
}

# walk lines
$linenrsadded = 0;

# run while within the quantity of lines
# or within the append line number
$linenr=0;
while ($linenr < count($lines) || $linenr <= $appendlinenr) {

  # still within lines range?
  $line = $linenr < count($lines) ? $lines[$linenr] : '';

  # line to append in?
  if ($linenr === $appendlinenr) {
    # append in character in line?
    if ($appendcharacter !== false) {

      # beginning and end of the line
      $begin = substr($line, 0, $appendcharacter);
      $end = substr($line, $appendcharacter);

      # walk the lines to append
      foreach ($append as $k => $v) {
        # first index?
        if ($k === 0) {
          # add the line from the start to the character in line
          $append[$k] = $begin.$v;
        }
        # last index?
        if ($k === count($append)-1) {
          # add the ending of the line
          $append[$k] = $v.$end;
        }
      }
    }
    # walk lines to append and do it
    foreach ($append as $k => $appendline) {
      cl('Line '.linenrprefix($linenr + $linenrsadded, $linecount).'+: '.trim($appendline), VERBOSE_DEBUG);
      if ($config['write']) {
        fputs($f, $appendline."\n");
      }
      # above append line 0 or append character is off
      if ($k > 0 || ($k === 0 && $appendcharacter === false)) {
        # increment lines added
        $linenrsadded++;
      }
    }

    # not appending on character
    # and within range for original lines
    if (
      $appendcharacter === false &&
      $linenr < count($lines)
    ) {
      # then print original line afterwards
      cl('Line '.linenrprefix($linenr + $linenrsadded, $linecount).'+: '.trim($line), VERBOSE_DEBUG);
      if ($config['write']) {
        fputs($f, $line);
      }
    }
  } else {
    # write regular line
    cl('Line '.linenrprefix($linenr + $linenrsadded, $linecount).' : '.trim($line), VERBOSE_DEBUG_DEEP);
    if ($config['write']) {
      fputs($f, $line);
    }
  }

  $linenr++;
}

# close file
if ($config['write']) {
  fclose($f);
}

?>
